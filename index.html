<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mux Minutes Delivered Calculator</title>
    <meta name="description" content="Visualize Mux billing in real-time. See exactly how minutes delivered are calculated as you play, seek, and switch quality levels.">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>&#9658;</text></svg>">
    <!-- Aeonik & JetBrains Mono from Google Fonts (closest available match for Aeonik via Inter; JetBrains Mono is available) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@mux/mux-player" defer></script>
    <style>
        /* â”€â”€â”€ Mux Brand System â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        :root {
            /* Core brand colors */
            --pink:       #FA50B5;
            --yellow:     #FFB200;
            --green:      #00AA3C;
            --orange:     #FF6100;
            --red:        #EA3737;
            --blue:       #0072E3;

            /* Grays */
            --black:      #000000;
            --charcoal:   #242628;
            --dark-gray:  #565E67;
            --gray:       #828C97;
            --putty:      #E2E4DD;
            --white:      #FFFFFF;

            /* Page tokens â€” light mode */
            --bg:         var(--putty);
            --surface:    var(--white);
            --surface-2:  #f0f1ed;
            --border:     #d0d2cc;
            --text:       var(--charcoal);
            --text-muted: var(--dark-gray);
            --accent:     var(--pink);
            --accent-alt: var(--yellow);

            /* Grid unit (macroblock-inspired 8px base) */
            --unit: 8px;

            /* Typography */
            --font-sans: 'Aeonik', 'Inter', system-ui, -apple-system, sans-serif;
            --font-mono: 'JetBrains Mono', 'Monaco', 'Menlo', monospace;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* â”€â”€â”€ Aeonik fallback via @font-face (loaded from CDN if available) â”€â”€ */
        /* We load Aeonik from the Mux CDN if it serves it; otherwise fall back to Inter */

        body {
            font-family: var(--font-sans);
            background-color: var(--bg);
            color: var(--text);
            min-height: 100vh;
            line-height: 1.6;
            font-size: 16px;
            -webkit-font-smoothing: antialiased;
        }

        /* â”€â”€â”€ Macroblock grid background â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background-image:
                linear-gradient(to right, rgba(0,0,0,0.05) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(0,0,0,0.05) 1px, transparent 1px);
            background-size: 32px 32px; /* 4 Ã— 8px units = macroblock-inspired */
            pointer-events: none;
            z-index: 0;
        }

        /* â”€â”€â”€ Layout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .container {
            position: relative;
            z-index: 1;
            max-width: 960px;
            margin: 0 auto;
            padding: calc(var(--unit) * 4) calc(var(--unit) * 3);
        }

        /* â”€â”€â”€ Header â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: calc(var(--unit) * 3);
            margin-bottom: calc(var(--unit) * 6);
            padding-bottom: calc(var(--unit) * 4);
            border-bottom: 1px solid var(--border);
        }

        .header-content {
            flex: 1;
        }

        .header-eyebrow {
            display: inline-flex;
            align-items: center;
            gap: calc(var(--unit) * 1);
            font-family: var(--font-mono);
            font-size: 11px;
            font-weight: 500;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: var(--pink);
            margin-bottom: calc(var(--unit) * 2);
        }

        .header-eyebrow::before {
            content: '';
            display: block;
            width: 16px;
            height: 2px;
            background: var(--pink);
            flex-shrink: 0;
        }

        header h1 {
            font-family: var(--font-sans);
            font-size: clamp(1.75rem, 4vw, 2.5rem);
            font-weight: 700;
            line-height: 1.15;
            letter-spacing: -0.02em;
            color: var(--white);
            margin-bottom: calc(var(--unit) * 1.5);
        }

        header h1 span {
            color: var(--pink);
        }

        .subtitle {
            color: var(--text-muted);
            font-size: 0.9375rem;
            max-width: 520px;
            line-height: 1.6;
        }

        /* Mux wordmark (text-based since we don't have the SVG) */
        .mux-logo {
            font-family: var(--font-sans);
            font-size: 1.5rem;
            font-weight: 800;
            letter-spacing: -0.04em;
            color: var(--white);
            flex-shrink: 0;
            line-height: 1;
            padding-top: 4px;
        }

        /* â”€â”€â”€ Section labels â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .section-label {
            font-family: var(--font-mono);
            font-size: 10px;
            font-weight: 500;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: var(--text-muted);
            margin-bottom: calc(var(--unit) * 1.5);
        }

        /* â”€â”€â”€ Cards / Surfaces â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: calc(var(--unit) * 3);
            margin-bottom: calc(var(--unit) * 3);
        }

        /* â”€â”€â”€ Form Elements â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .form-group {
            margin-bottom: calc(var(--unit) * 2.5);
        }

        label {
            display: block;
            margin-bottom: calc(var(--unit) * 1);
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--white);
        }

        .label-hint {
            font-weight: 400;
            color: var(--text-muted);
            font-size: 0.8125rem;
        }

        input[type="text"],
        input[type="number"],
        select {
            width: 100%;
            padding: calc(var(--unit) * 1.5) calc(var(--unit) * 2);
            background: var(--surface-2);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            font-size: 0.9375rem;
            font-family: var(--font-mono);
            transition: border-color 0.15s, box-shadow 0.15s;
            outline: none;
            appearance: none;
            -webkit-appearance: none;
        }

        input:focus,
        select:focus {
            border-color: var(--pink);
            box-shadow: 0 0 0 3px rgba(250, 80, 181, 0.15);
        }

        select {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23828C97' stroke-width='2'%3E%3Cpolyline points='6 9 12 15 18 9'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            padding-right: calc(var(--unit) * 5);
            cursor: pointer;
        }

        /* â”€â”€â”€ Buttons â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: calc(var(--unit) * 1);
            padding: calc(var(--unit) * 1.5) calc(var(--unit) * 3);
            border: none;
            border-radius: 8px;
            font-size: 0.9375rem;
            font-family: var(--font-sans);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
            letter-spacing: -0.01em;
        }

        .btn-primary {
            background: var(--pink);
            color: var(--white);
        }

        .btn-primary:hover {
            background: #e03da3;
            transform: translateY(-1px);
            box-shadow: 0 4px 16px rgba(250, 80, 181, 0.35);
        }

        .btn-primary:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: transparent;
            color: var(--text-muted);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            border-color: var(--text-muted);
            color: var(--white);
        }

        .btn-group {
            display: flex;
            gap: calc(var(--unit) * 1.5);
            flex-wrap: wrap;
        }

        /* â”€â”€â”€ Buffer Config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .buffer-config-header {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--white);
            margin-bottom: calc(var(--unit) * 2);
        }

        .buffer-config-header .label-hint {
            font-weight: 400;
        }

        .buffer-config-fields {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: calc(var(--unit) * 2);
        }

        .buffer-config-fields .form-group {
            margin-bottom: 0;
        }

        .buffer-preset-description {
            font-size: 0.8125rem;
            color: var(--text-muted);
            line-height: 1.55;
            margin-bottom: calc(var(--unit) * 2);
            min-height: 1.2em;
            padding: calc(var(--unit) * 1.5) calc(var(--unit) * 2);
            background: rgba(255,255,255,0.04);
            border-left: 3px solid var(--pink);
            border-radius: 0 6px 6px 0;
        }

        .buffer-hint {
            margin-top: calc(var(--unit) * 2);
            font-size: 0.8125rem;
            color: var(--text-muted);
            line-height: 1.55;
        }

        @media (max-width: 700px) {
            .buffer-config-fields {
                grid-template-columns: 1fr;
            }
        }

        /* â”€â”€â”€ Player â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .player-section {
            margin-top: calc(var(--unit) * 4);
        }

        .player-wrapper {
            background: var(--charcoal);
            border: 1px solid var(--border);
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: calc(var(--unit) * 3);
        }

        .player-wrapper mux-player {
            display: block;
            width: 100%;
            aspect-ratio: 16 / 9;
            --media-accent-color: var(--pink);
        }

        /* â”€â”€â”€ Player Info Grid â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: calc(var(--unit) * 1.5);
        }

        .info-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .info-label {
            font-size: 0.6875rem;
            font-family: var(--font-mono);
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .info-value {
            font-family: var(--font-mono);
            font-size: 0.875rem;
            color: var(--white);
        }

        /* â”€â”€â”€ Delivery Billing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .delivery-section h3 {
            font-size: 1.0625rem;
            font-weight: 600;
            color: var(--white);
            margin-bottom: calc(var(--unit) * 1);
        }

        .delivery-intro {
            font-size: 0.875rem;
            color: var(--text-muted);
            line-height: 1.6;
            margin-bottom: calc(var(--unit) * 3);
        }

        .delivery-intro strong {
            color: var(--white);
            font-weight: 600;
        }

        /* â”€â”€â”€ Big Numbers (Watch Time vs Minutes Delivered) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .billing-highlight {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            gap: calc(var(--unit) * 3);
            background: var(--surface-2);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: calc(var(--unit) * 4) calc(var(--unit) * 3);
            margin-bottom: calc(var(--unit) * 2);
            position: relative;
            overflow: hidden;
        }

        /* Pink accent line at top */
        .billing-highlight::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--pink), var(--yellow));
        }

        .billing-main {
            text-align: center;
            cursor: help;
        }

        .billing-value {
            font-family: var(--font-mono);
            font-size: clamp(2rem, 5vw, 3rem);
            font-weight: 600;
            color: var(--pink);
            line-height: 1;
            margin-bottom: calc(var(--unit) * 1);
            letter-spacing: -0.02em;
        }

        .billing-label {
            font-family: var(--font-mono);
            font-size: 0.6875rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .billing-vs {
            font-family: var(--font-mono);
            font-size: 0.75rem;
            color: var(--dark-gray);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            text-align: center;
        }

        /* â”€â”€â”€ Insight Box â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .insight-box {
            display: flex;
            align-items: flex-start;
            gap: calc(var(--unit) * 1.5);
            padding: calc(var(--unit) * 2);
            background: rgba(255, 178, 0, 0.06);
            border: 1px solid rgba(255, 178, 0, 0.2);
            border-radius: 8px;
            margin-bottom: calc(var(--unit) * 2);
        }

        .insight-icon {
            font-size: 1.125rem;
            line-height: 1.4;
            flex-shrink: 0;
        }

        .insight-text {
            color: var(--text-muted);
            font-size: 0.875rem;
            line-height: 1.6;
        }

        .insight-text strong {
            color: var(--white);
            font-weight: 600;
        }

        .insight-text em {
            color: var(--text-muted);
            font-style: normal;
            opacity: 0.8;
        }

        /* â”€â”€â”€ KPI Cards â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .kpi-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: calc(var(--unit) * 1.5);
            margin-bottom: calc(var(--unit) * 2);
        }

        @media (max-width: 700px) {
            .kpi-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .kpi-card {
            background: var(--surface-2);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: calc(var(--unit) * 2) calc(var(--unit) * 1.5);
            text-align: center;
            cursor: help;
            transition: border-color 0.15s;
        }

        .kpi-card:hover {
            border-color: var(--dark-gray);
        }

        .kpi-value {
            font-family: var(--font-mono);
            font-size: 1.0625rem;
            font-weight: 600;
            color: var(--pink);
            line-height: 1;
            margin-bottom: 4px;
        }

        .kpi-label {
            font-family: var(--font-mono);
            font-size: 0.625rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        /* â”€â”€â”€ Tooltips â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        [data-tooltip] {
            position: relative;
        }

        [data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: var(--white);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: calc(var(--unit) * 1.5);
            font-size: 0.75rem;
            font-family: var(--font-sans);
            color: var(--text-muted);
            width: 220px;
            text-align: left;
            z-index: 100;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            line-height: 1.5;
            pointer-events: none;
        }

        [data-tooltip]:hover::before {
            content: '';
            position: absolute;
            bottom: calc(100% + 2px);
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: var(--border);
            z-index: 101;
            pointer-events: none;
        }

        .billing-main[data-tooltip]:hover::after {
            width: 280px;
        }

        /* â”€â”€â”€ Charts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .charts-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: calc(var(--unit) * 2);
        }

        @media (max-width: 700px) {
            .charts-row {
                grid-template-columns: 1fr;
            }
        }

        .chart-container {
            background: var(--surface-2);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: calc(var(--unit) * 2);
            padding-top: calc(var(--unit) * 1.5);
            height: 220px;
            position: relative;
        }

        .chart-title {
            font-family: var(--font-mono);
            font-size: 0.6875rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: calc(var(--unit) * 1);
            text-align: center;
        }

        .chart-canvas {
            width: 100%;
            height: calc(100% - 24px);
        }

        /* â”€â”€â”€ Segment Log â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .segment-log-details {
            margin-top: calc(var(--unit) * 2);
        }

        .segment-log-details summary {
            cursor: pointer;
            color: var(--text-muted);
            font-size: 0.8125rem;
            font-family: var(--font-mono);
            padding: calc(var(--unit) * 1) 0;
            user-select: none;
            list-style: none;
            display: flex;
            align-items: center;
            gap: calc(var(--unit) * 1);
        }

        .segment-log-details summary::before {
            content: 'â–¶';
            font-size: 0.625rem;
            transition: transform 0.15s;
        }

        .segment-log-details[open] summary::before {
            transform: rotate(90deg);
        }

        .segment-log-details summary:hover {
            color: var(--white);
        }

        .segment-log-details[open] summary {
            margin-bottom: calc(var(--unit) * 1);
        }

        .segment-log {
            max-height: 200px;
            overflow-y: auto;
            background: var(--surface-2);
            border: 1px solid var(--border);
            border-radius: 8px;
            font-family: var(--font-mono);
        }

        .segment-log-header {
            display: grid;
            grid-template-columns: 70px 1fr 80px 80px;
            gap: calc(var(--unit) * 1);
            padding: calc(var(--unit) * 1) calc(var(--unit) * 2);
            background: var(--border);
            font-size: 0.625rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            position: sticky;
            top: 0;
        }

        .segment-log-entry {
            display: grid;
            grid-template-columns: 70px 1fr 80px 80px;
            gap: calc(var(--unit) * 1);
            padding: calc(var(--unit) * 1) calc(var(--unit) * 2);
            font-size: 0.75rem;
            border-bottom: 1px solid var(--border);
            color: var(--text-muted);
        }

        .segment-log-entry:last-child {
            border-bottom: none;
        }

        .segment-type {
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.625rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: 600;
        }

        .segment-type.video   { background: rgba(0, 114, 227, 0.2); color: #60aaff; }
        .segment-type.audio   { background: rgba(0, 170, 60, 0.2);  color: #34c95e; }
        .segment-type.init    { background: rgba(255, 178, 0, 0.15); color: #FFB200; }
        .segment-type.cached  { background: rgba(130, 140, 151, 0.15); color: var(--gray); }

        .segment-log-entry.cached {
            opacity: 0.5;
        }

        /* â”€â”€â”€ Divider â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .section-divider {
            border: none;
            border-top: 1px solid var(--border);
            margin: calc(var(--unit) * 3) 0;
        }

        /* â”€â”€â”€ Footer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        footer {
            margin-top: calc(var(--unit) * 6);
            padding-top: calc(var(--unit) * 4);
            border-top: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: calc(var(--unit) * 2);
        }

        .footer-brand {
            font-size: 0.875rem;
            color: var(--text-muted);
        }

        .footer-brand strong {
            color: var(--white);
            font-weight: 600;
        }

        .footer-links {
            display: flex;
            gap: calc(var(--unit) * 3);
        }

        .footer-links a {
            font-family: var(--font-mono);
            font-size: 0.75rem;
            color: var(--text-muted);
            text-decoration: none;
            letter-spacing: 0.03em;
            transition: color 0.15s;
        }

        .footer-links a:hover {
            color: var(--pink);
        }

        /* â”€â”€â”€ Responsive â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        @media (max-width: 600px) {
            .container {
                padding: calc(var(--unit) * 2);
            }

            header {
                flex-direction: column-reverse;
                gap: calc(var(--unit) * 2);
            }

            .billing-highlight {
                grid-template-columns: 1fr;
                text-align: center;
            }

            .billing-vs {
                text-align: center;
            }

            .kpi-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .btn-group {
                flex-direction: column;
            }

            .btn {
                width: 100%;
            }

            footer {
                flex-direction: column;
                text-align: center;
            }

            .footer-links {
                justify-content: center;
            }
        }

        /* â”€â”€â”€ Form row â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: calc(var(--unit) * 2);
        }

        @media (max-width: 600px) {
            .form-row {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- â”€â”€â”€ Header â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
        <header>
            <div class="header-content">
                <div class="header-eyebrow">Mux Video Pricing</div>
                <h1>Minutes Delivered<br><span>Calculator</span></h1>
                <p class="subtitle">See exactly how delivery billing is calculated as video segments are sent to your player â€” including buffered content you haven't watched yet.</p>
            </div>
            <div class="mux-logo" aria-label="Mux">Mux</div>
        </header>

        <!-- â”€â”€â”€ Config Form â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
        <form id="player-form">
            <div class="card">
                <div class="section-label">Playback</div>
                <div class="form-group" style="margin-bottom: 0;">
                    <label for="playback-id">
                        Playback ID
                        <span class="label-hint">â€” the Mux playback ID for the video</span>
                    </label>
                    <input type="text" id="playback-id" placeholder="e.g., VwLWM93xOArWvbzvbZO901FmRpMBjTp9VTFD7bAmJemc" value="VwLWM93xOArWvbzvbZO901FmRpMBjTp9VTFD7bAmJemc" required>
                </div>
            </div>

            <div class="card">
                <div class="section-label">Buffer Configuration</div>
                <div class="buffer-config-header">
                    Buffer Settings
                    <span class="label-hint"> â€” controls how much video is downloaded ahead of playback</span>
                </div>
                <div class="form-group" style="margin-bottom: calc(var(--unit) * 1);">
                    <label for="buffer-preset">Preset</label>
                    <select id="buffer-preset">
                        <option value="performance">Performance optimised â€” maximum buffer for smooth playback</option>
                        <option value="balanced">Balanced â€” moderate buffer, reduced delivery cost</option>
                        <option value="cost">Cost optimised â€” minimal buffer to minimise minutes delivered</option>
                    </select>
                </div>
                <p class="buffer-preset-description" id="buffer-preset-description"></p>
                <div class="buffer-config-fields">
                    <div class="form-group">
                        <label for="max-buffer-length">
                            maxBufferLength
                            <span class="label-hint">â€” max forward buffer (s)</span>
                        </label>
                        <input type="number" id="max-buffer-length" placeholder="30" min="1" step="1">
                    </div>
                    <div class="form-group">
                        <label for="max-buffer-size">
                            maxBufferSize
                            <span class="label-hint">â€” min buffer size (MB)</span>
                        </label>
                        <input type="number" id="max-buffer-size" placeholder="60" min="1" step="1">
                    </div>
                    <div class="form-group">
                        <label for="max-max-buffer-length">
                            maxMaxBufferLength
                            <span class="label-hint">â€” hard cap (s)</span>
                        </label>
                        <input type="number" id="max-max-buffer-length" placeholder="600" min="1" step="1">
                    </div>
                </div>
                <p class="buffer-hint">Reducing the buffer length means fewer segments are downloaded ahead of time, which lowers minutes delivered. The tradeoff is a higher risk of rebuffering on slow networks.</p>
            </div>

            <div class="btn-group">
                <button type="submit" class="btn btn-primary">Load Player</button>
                <button type="button" class="btn btn-secondary" id="clear-btn">Clear</button>
            </div>
        </form>

        <!-- â”€â”€â”€ Player Section â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
        <div class="player-section" id="player-section" style="display: none;">
            <div class="player-wrapper" id="player-wrapper"></div>

            <!-- Player Info -->
            <div class="card">
                <div class="section-label">Player Info</div>
                <div class="info-grid">
                    <div class="info-item">
                        <span class="info-label">Duration</span>
                        <span class="info-value" id="info-duration">â€”</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Current Time</span>
                        <span class="info-value" id="info-current-time">â€”</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">State</span>
                        <span class="info-value" id="info-state">â€”</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Volume</span>
                        <span class="info-value" id="info-volume">â€”</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Buffered</span>
                        <span class="info-value" id="info-buffered">â€”</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Stream Type</span>
                        <span class="info-value" id="info-stream-type">â€”</span>
                    </div>
                </div>
            </div>

            <!-- Delivery Billing -->
            <div class="card delivery-section">
                <div class="section-label">Understanding Delivery Billing</div>
                <h3>Watch Time vs. Minutes Delivered</h3>
                <p class="delivery-intro">
                    Mux measures <strong>minutes delivered</strong> by counting the seconds of video sent to the player.
                    This includes buffered content â€” if the player buffers 20 seconds ahead, those 20 seconds count
                    toward delivery even if they're never watched.
                </p>

                <div class="billing-highlight">
                    <div class="billing-main" data-tooltip="How long you've actually watched the video.">
                        <div class="billing-value" id="kpi-watch-time">0:00</div>
                        <div class="billing-label">Watch Time</div>
                    </div>
                    <div class="billing-vs">vs</div>
                    <div class="billing-main" data-tooltip="Delivery is measured per minute of video sent to the player. This includes buffered content you haven't watched yet.">
                        <div class="billing-value" id="kpi-minutes-delivered">0:00</div>
                        <div class="billing-label">Minutes Delivered</div>
                    </div>
                </div>

                <div class="insight-box" id="insight-box">
                    <div class="insight-icon">ðŸ’¡</div>
                    <div class="insight-text" id="insight-text">Start playback to see delivery insights. Notice how buffering ahead adds to minutes delivered even before you watch that content.</div>
                </div>

                <div class="kpi-grid">
                    <div class="kpi-card" data-tooltip="Total bytes downloaded from Mux CDN (video + audio). Bandwidth varies by quality level, but all resolutions cost the same per minute delivered.">
                        <div class="kpi-value" id="kpi-total-data">0 KB</div>
                        <div class="kpi-label">Data Downloaded</div>
                    </div>
                    <div class="kpi-card" data-tooltip="Video data only. Higher resolutions (1080p, 4K) use more bandwidth but cost the same in minutes delivered as lower resolutions.">
                        <div class="kpi-value" id="kpi-video-data">0 KB</div>
                        <div class="kpi-label">Video</div>
                    </div>
                    <div class="kpi-card" data-tooltip="Audio is delivered separately from video.">
                        <div class="kpi-value" id="kpi-audio-data">0 KB</div>
                        <div class="kpi-label">Audio</div>
                    </div>
                    <div class="kpi-card" data-tooltip="Segments served from browser cache were already billed when first downloaded. Cached content doesn't count again.">
                        <div class="kpi-value" id="kpi-cached-data">0 KB</div>
                        <div class="kpi-label">From Cache</div>
                    </div>
                </div>

                <div class="charts-row">
                    <div class="chart-container">
                        <div class="chart-title">Bandwidth by Quality</div>
                        <canvas id="data-chart" class="chart-canvas"></canvas>
                    </div>
                    <div class="chart-container">
                        <div class="chart-title">Minutes by Quality</div>
                        <canvas id="minutes-chart" class="chart-canvas"></canvas>
                    </div>
                </div>

                <details class="segment-log-details">
                    <summary>Segment Download Log</summary>
                    <div class="segment-log" id="segment-log">
                        <div class="segment-log-header">
                            <span>Time</span>
                            <span>Segment</span>
                            <span>Size</span>
                            <span>Type</span>
                        </div>
                        <div id="segment-log-entries"></div>
                    </div>
                </details>
            </div>
        </div>

        <!-- â”€â”€â”€ Footer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
        <footer>
            <div class="footer-brand">
                Built with <strong>Mux</strong> â€” video infrastructure for developers
            </div>
            <nav class="footer-links">
                <a href="https://mux.com" target="_blank" rel="noopener">mux.com</a>
                <a href="https://www.mux.com/docs/pricing/video" target="_blank" rel="noopener">Pricing Docs</a>
            </nav>
        </footer>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const form = document.getElementById('player-form');
            const clearBtn = document.getElementById('clear-btn');
            const playerSection = document.getElementById('player-section');
            const playerWrapper = document.getElementById('player-wrapper');

            let muxPlayer = null;
            let infoInterval = null;
            let watchTimeInterval = null;
            let watchTimeStart = null;
            let accumulatedWatchTime = 0;

            // Data usage tracking
            let dataUsage = {
                totalBytes: 0,
                videoBytes: 0,
                audioBytes: 0,
                cachedBytes: 0,
                segmentCount: 0,
                cachedSegmentCount: 0,
                videoDuration: 0,
                qualitySwitches: 0,
                segments: [],
                byRendition: {},
                startTime: null,
                currentLevel: null
            };
            let chartCtx = null;
            let minutesChartCtx = null;

            // Mux brand palette for charts
            const renditionColors = [
                '#FA50B5', '#FFB200', '#00AA3C', '#0072E3',
                '#FF6100', '#EA3737', '#828C97', '#E2E4DD'
            ];

            const bufferPresets = {
                performance: {
                    maxBufferLength: 30, maxBufferSize: 60, maxMaxBufferLength: 600,
                    description: 'Uses hls.js defaults. Buffers up to 30 seconds ahead for smooth, uninterrupted playback. Best for viewers on stable connections where experience is the priority.'
                },
                balanced: {
                    maxBufferLength: 10, maxBufferSize: 20, maxMaxBufferLength: 20,
                    description: 'A middle ground. Buffers ~10 seconds ahead â€” enough to handle brief network hiccups while meaningfully reducing the amount of video delivered before it\'s watched.'
                },
                cost: {
                    maxBufferLength: 5, maxBufferSize: 10, maxMaxBufferLength: 10,
                    description: 'Keeps the buffer as short as possible to minimise minutes delivered. Higher risk of rebuffering on slower or unstable connections. Best suited for controlled network environments.'
                }
            };

            function applyPresetDescription(value) {
                document.getElementById('buffer-preset-description').textContent = bufferPresets[value].description;
            }

            document.getElementById('buffer-preset').addEventListener('change', (e) => {
                const preset = bufferPresets[e.target.value];
                document.getElementById('max-buffer-length').value = preset.maxBufferLength;
                document.getElementById('max-buffer-size').value = preset.maxBufferSize;
                document.getElementById('max-max-buffer-length').value = preset.maxMaxBufferLength;
                applyPresetDescription(e.target.value);
            });

            applyPresetDescription('performance');

            form.addEventListener('submit', (e) => {
                e.preventDefault();
                loadPlayer();
            });

            clearBtn.addEventListener('click', () => {
                destroyPlayer();
                form.reset();
                document.getElementById('playback-id').value = 'VwLWM93xOArWvbzvbZO901FmRpMBjTp9VTFD7bAmJemc';
                playerSection.style.display = 'none';
                applyPresetDescription('performance');
            });

            function loadPlayer() {
                destroyPlayer();

                const playbackId = document.getElementById('playback-id').value.trim();
                if (!playbackId) {
                    alert('Please enter a playback ID');
                    return;
                }

                muxPlayer = document.createElement('mux-player');
                muxPlayer.setAttribute('playback-id', playbackId);
                muxPlayer.style.setProperty('--media-accent-color', '#FA50B5');

                playerWrapper.innerHTML = '';
                playerWrapper.appendChild(muxPlayer);
                playerSection.style.display = 'block';

                setupPlayerEvents();
                setupDataTracking();
                startInfoUpdates();
            }

            function resetDataUsage() {
                dataUsage = {
                    totalBytes: 0,
                    videoBytes: 0,
                    audioBytes: 0,
                    cachedBytes: 0,
                    segmentCount: 0,
                    cachedSegmentCount: 0,
                    videoDuration: 0,
                    qualitySwitches: 0,
                    segments: [],
                    byRendition: {},
                    startTime: Date.now(),
                    currentLevel: null
                };
                accumulatedWatchTime = 0;
                watchTimeStart = null;
                document.getElementById('segment-log-entries').innerHTML = '';
                updateDataUsageDisplay();
                updateInsight();
                drawCharts();
            }

            function setupDataTracking() {
                if (!muxPlayer) return;
                resetDataUsage();

                const checkHls = () => {
                    const hls = muxPlayer._hls;
                    if (hls) {
                        const maxBufferLength = document.getElementById('max-buffer-length').value;
                        const maxBufferSize = document.getElementById('max-buffer-size').value;
                        const maxMaxBufferLength = document.getElementById('max-max-buffer-length').value;

                        if (maxBufferLength) hls.config.maxBufferLength = parseFloat(maxBufferLength);
                        if (maxBufferSize) hls.config.maxBufferSize = parseFloat(maxBufferSize) * 1024 * 1024;
                        if (maxMaxBufferLength) hls.config.maxMaxBufferLength = parseFloat(maxMaxBufferLength);

                        const Hls = hls.constructor;
                        const fragLoadedEvent = Hls.Events?.FRAG_LOADED || 'hlsFragLoaded';
                        hls.on(fragLoadedEvent, (event, data) => {
                            onFragmentLoaded(data);
                        });
                    } else {
                        setTimeout(checkHls, 100);
                    }
                };
                setTimeout(checkHls, 100);
            }

            function onFragmentLoaded(data) {
                const frag = data.frag;
                const stats = data.stats || frag.stats;

                let size = 0;
                if (stats && stats.total) {
                    size = stats.total;
                } else if (stats && stats.loaded) {
                    size = stats.loaded;
                } else if (data.payload) {
                    size = data.payload.byteLength;
                }

                let isCached = false;
                if (stats && stats.loading) {
                    const loadTime = stats.loading.end - stats.loading.start;
                    isCached = loadTime < 50 && size > 10000;
                }

                let type = 'video';
                if (frag.type === 'audio') {
                    type = 'audio';
                } else if (frag.type === 'main' && frag.sn === 'initSegment') {
                    type = 'init';
                } else if (frag.sn === 'initSegment') {
                    type = 'init';
                }

                if (type === 'video' && !isCached) {
                    if (dataUsage.currentLevel !== null && dataUsage.currentLevel !== frag.level) {
                        dataUsage.qualitySwitches++;
                    }
                    dataUsage.currentLevel = frag.level;
                }

                const segmentName = frag.sn === 'initSegment'
                    ? `init-${frag.level}`
                    : `seg-${frag.sn}-lvl${frag.level}`;

                const now = Date.now();
                const elapsedSec = (now - dataUsage.startTime) / 1000;

                if (isCached) {
                    dataUsage.cachedBytes += size;
                    dataUsage.cachedSegmentCount++;
                } else {
                    dataUsage.totalBytes += size;
                    dataUsage.segmentCount++;

                    if (type === 'audio') {
                        dataUsage.audioBytes += size;
                    } else {
                        dataUsage.videoBytes += size;

                        const segmentDuration = frag.duration || 0;
                        if (type === 'video' && segmentDuration > 0) {
                            dataUsage.videoDuration += segmentDuration;
                        }

                        const level = frag.level;
                        if (!dataUsage.byRendition[level]) {
                            let resolution = `Level ${level}`;
                            const hls = muxPlayer?._hls;
                            if (hls && hls.levels && hls.levels[level]) {
                                const lvl = hls.levels[level];
                                if (lvl.height) {
                                    resolution = `${lvl.height}p`;
                                } else if (lvl.width) {
                                    resolution = `${lvl.width}w`;
                                }
                            }
                            dataUsage.byRendition[level] = {
                                bytes: 0,
                                segments: 0,
                                resolution: resolution,
                                duration: 0
                            };
                        }
                        if (type === 'video' && segmentDuration > 0) {
                            dataUsage.byRendition[level].duration += segmentDuration;
                        }
                        dataUsage.byRendition[level].bytes += size;
                        dataUsage.byRendition[level].segments++;
                    }
                }

                const segment = {
                    time: elapsedSec,
                    name: segmentName,
                    size: size,
                    type: type,
                    level: frag.level,
                    sn: frag.sn,
                    duration: frag.duration || 0,
                    cached: isCached
                };
                dataUsage.segments.push(segment);

                addSegmentLogEntry(segment);
                updateDataUsageDisplay();
                updateInsight();
                drawCharts();
            }

            function addSegmentLogEntry(segment) {
                const entries = document.getElementById('segment-log-entries');
                const entry = document.createElement('div');
                entry.className = 'segment-log-entry' + (segment.cached ? ' cached' : '');

                const typeLabel = segment.cached ? 'cached' : segment.type;
                const typeClass = segment.cached ? 'cached' : segment.type;

                entry.innerHTML = `
                    <span>${segment.time.toFixed(1)}s</span>
                    <span>${segment.name}</span>
                    <span>${formatBytes(segment.size)}</span>
                    <span><span class="segment-type ${typeClass}">${typeLabel}</span></span>
                `;
                entries.insertBefore(entry, entries.firstChild);

                while (entries.children.length > 50) {
                    entries.removeChild(entries.lastChild);
                }
            }

            function getWatchTime() {
                if (watchTimeStart !== null) {
                    return accumulatedWatchTime + (Date.now() - watchTimeStart) / 1000;
                }
                return accumulatedWatchTime;
            }

            function updateDataUsageDisplay() {
                document.getElementById('kpi-watch-time').textContent = formatDuration(getWatchTime());
                document.getElementById('kpi-minutes-delivered').textContent = formatDuration(dataUsage.videoDuration);
                document.getElementById('kpi-total-data').textContent = formatBytes(dataUsage.totalBytes);
                document.getElementById('kpi-video-data').textContent = formatBytes(dataUsage.videoBytes);
                document.getElementById('kpi-audio-data').textContent = formatBytes(dataUsage.audioBytes);
                document.getElementById('kpi-cached-data').textContent = formatBytes(dataUsage.cachedBytes);
            }

            function formatDuration(seconds) {
                if (!seconds || seconds === 0) return '0:00';
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }

            function updateInsight() {
                const insightEl = document.getElementById('insight-text');
                if (!insightEl) return;

                const delivered = dataUsage.videoDuration;
                const renditions = Object.values(dataUsage.byRendition);
                const switches = dataUsage.qualitySwitches;

                let insight = '';

                if (delivered === 0) {
                    insight = 'Start playback to see delivery in action. Watch how buffering ahead increases minutes delivered â€” the player downloads segments before you watch them.';
                } else if (switches > 0 && renditions.length > 1) {
                    insight = `<strong>Quality switching detected:</strong> ${formatDuration(delivered)} delivered across ${renditions.length} quality levels. Quality changes may re-download segments at the new bitrate. Remember: all resolutions cost the same per minute delivered.`;
                } else if (renditions.length > 1) {
                    const sorted = renditions.sort((a, b) => (b.duration || 0) - (a.duration || 0));
                    const topRendition = sorted[0];
                    insight = `<strong>Adaptive streaming:</strong> ${formatDuration(delivered)} delivered, mostly at <strong>${topRendition.resolution}</strong>. The player selects quality based on your connection. Higher resolutions use more bandwidth but cost the same per minute.`;
                } else if (renditions.length === 1) {
                    const rendition = renditions[0];
                    insight = `<strong>${formatDuration(delivered)} delivered</strong> at <strong>${rendition.resolution}</strong>. You're billed for exact seconds with no rounding. Try seeking ahead to see how the player buffers additional content.`;
                } else {
                    insight = `<strong>${formatDuration(delivered)} minutes delivered</strong> so far. Each video segment downloaded counts toward this total, including buffered content that hasn't been watched yet.`;
                }

                if (dataUsage.cachedBytes > 0) {
                    const cachedPercent = ((dataUsage.cachedBytes / (dataUsage.totalBytes + dataUsage.cachedBytes)) * 100).toFixed(0);
                    insight += ` <em>${cachedPercent}% came from browser cache (already billed on first download).</em>`;
                }

                insightEl.innerHTML = insight;
            }

            function drawCharts() {
                const renditions = Object.entries(dataUsage.byRendition)
                    .map(([level, data]) => ({ level: parseInt(level), ...data }))
                    .sort((a, b) => {
                        const resA = parseInt(a.resolution) || 0;
                        const resB = parseInt(b.resolution) || 0;
                        return resB - resA;
                    });

                drawDataChart(renditions);
                drawMinutesChart(renditions);
            }

            function drawDataChart(renditions) {
                const canvas = document.getElementById('data-chart');
                if (!canvas) return;
                if (!chartCtx) chartCtx = canvas.getContext('2d');

                const ctx = chartCtx;
                const dpr = window.devicePixelRatio || 1;
                const drawWidth = canvas.offsetWidth;
                const drawHeight = canvas.offsetHeight;

                canvas.width = drawWidth * dpr;
                canvas.height = drawHeight * dpr;
                ctx.scale(dpr, dpr);
                ctx.clearRect(0, 0, drawWidth, drawHeight);

                if (renditions.length === 0) {
                    ctx.fillStyle = '#828C97';
                    ctx.font = '12px JetBrains Mono, monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('Waiting for video data...', drawWidth / 2, drawHeight / 2);
                    return;
                }

                const totalVideoBytes = renditions.reduce((sum, r) => sum + r.bytes, 0);
                const centerX = drawWidth * 0.35;
                const centerY = drawHeight / 2;
                const radius = Math.min(drawWidth * 0.3, drawHeight * 0.4);
                let startAngle = -Math.PI / 2;

                renditions.forEach((rendition, index) => {
                    const sliceAngle = (rendition.bytes / totalVideoBytes) * Math.PI * 2;
                    const endAngle = startAngle + sliceAngle;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                    ctx.closePath();
                    ctx.fillStyle = renditionColors[index % renditionColors.length];
                    ctx.fill();
                    ctx.strokeStyle = '#f0f1ed';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    startAngle = endAngle;
                });

                // Donut hole
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius * 0.5, 0, Math.PI * 2);
                ctx.fillStyle = '#f0f1ed';
                ctx.fill();

                ctx.fillStyle = '#242628';
                ctx.font = 'bold 13px JetBrains Mono, monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(formatBytes(totalVideoBytes), centerX, centerY - 8);
                ctx.fillStyle = '#565E67';
                ctx.font = '10px JetBrains Mono, monospace';
                ctx.fillText('Video Total', centerX, centerY + 10);

                const legendX = drawWidth * 0.55;
                let legendY = 20;
                const legendSpacing = 28;
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';

                renditions.forEach((rendition, index) => {
                    const percent = ((rendition.bytes / totalVideoBytes) * 100).toFixed(1);
                    ctx.fillStyle = renditionColors[index % renditionColors.length];
                    ctx.fillRect(legendX, legendY - 6, 12, 12);
                    ctx.fillStyle = '#242628';
                    ctx.font = 'bold 12px JetBrains Mono, monospace';
                    ctx.fillText(rendition.resolution, legendX + 18, legendY);
                    ctx.fillStyle = '#565E67';
                    ctx.font = '11px JetBrains Mono, monospace';
                    ctx.fillText(`${formatBytes(rendition.bytes)} (${percent}%)`, legendX + 18, legendY + 14);
                    legendY += legendSpacing;
                });
            }

            function drawMinutesChart(renditions) {
                const canvas = document.getElementById('minutes-chart');
                if (!canvas) return;
                if (!minutesChartCtx) minutesChartCtx = canvas.getContext('2d');

                const ctx = minutesChartCtx;
                const dpr = window.devicePixelRatio || 1;
                const drawWidth = canvas.offsetWidth;
                const drawHeight = canvas.offsetHeight;

                canvas.width = drawWidth * dpr;
                canvas.height = drawHeight * dpr;
                ctx.scale(dpr, dpr);
                ctx.clearRect(0, 0, drawWidth, drawHeight);

                const totalDuration = renditions.reduce((sum, r) => sum + (r.duration || 0), 0);

                if (renditions.length === 0 || totalDuration === 0) {
                    ctx.fillStyle = '#565E67';
                    ctx.font = '12px JetBrains Mono, monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('Waiting for video data...', drawWidth / 2, drawHeight / 2);
                    return;
                }

                const centerX = drawWidth * 0.35;
                const centerY = drawHeight / 2;
                const radius = Math.min(drawWidth * 0.3, drawHeight * 0.4);
                let startAngle = -Math.PI / 2;

                renditions.forEach((rendition, index) => {
                    const duration = rendition.duration || 0;
                    if (duration === 0) return;
                    const sliceAngle = (duration / totalDuration) * Math.PI * 2;
                    const endAngle = startAngle + sliceAngle;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                    ctx.closePath();
                    ctx.fillStyle = renditionColors[index % renditionColors.length];
                    ctx.fill();
                    ctx.strokeStyle = '#f0f1ed';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    startAngle = endAngle;
                });

                ctx.beginPath();
                ctx.arc(centerX, centerY, radius * 0.5, 0, Math.PI * 2);
                ctx.fillStyle = '#f0f1ed';
                ctx.fill();

                ctx.fillStyle = '#242628';
                ctx.font = 'bold 13px JetBrains Mono, monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(formatDuration(totalDuration), centerX, centerY - 8);
                ctx.fillStyle = '#565E67';
                ctx.font = '10px JetBrains Mono, monospace';
                ctx.fillText('Total Minutes', centerX, centerY + 10);

                const legendX = drawWidth * 0.55;
                let legendY = 20;
                const legendSpacing = 28;
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';

                renditions.forEach((rendition, index) => {
                    const duration = rendition.duration || 0;
                    if (duration === 0) return;
                    const percent = ((duration / totalDuration) * 100).toFixed(1);
                    ctx.fillStyle = renditionColors[index % renditionColors.length];
                    ctx.fillRect(legendX, legendY - 6, 12, 12);
                    ctx.fillStyle = '#242628';
                    ctx.font = 'bold 12px JetBrains Mono, monospace';
                    ctx.fillText(rendition.resolution, legendX + 18, legendY);
                    ctx.fillStyle = '#565E67';
                    ctx.font = '11px JetBrains Mono, monospace';
                    ctx.fillText(`${formatDuration(duration)} (${percent}%)`, legendX + 18, legendY + 14);
                    legendY += legendSpacing;
                });
            }

            function destroyPlayer() {
                if (infoInterval) { clearInterval(infoInterval); infoInterval = null; }
                if (watchTimeInterval) { clearInterval(watchTimeInterval); watchTimeInterval = null; }
                watchTimeStart = null;
                accumulatedWatchTime = 0;

                if (muxPlayer) {
                    const hls = muxPlayer._hls;
                    if (hls) hls.off('hlsFragLoaded');
                    muxPlayer.remove();
                    muxPlayer = null;
                }

                chartCtx = null;
                minutesChartCtx = null;
            }

            function startWatchTimer() {
                if (watchTimeStart === null) watchTimeStart = Date.now();
                if (!watchTimeInterval) watchTimeInterval = setInterval(updateDataUsageDisplay, 100);
            }

            function stopWatchTimer() {
                if (watchTimeStart !== null) {
                    accumulatedWatchTime += (Date.now() - watchTimeStart) / 1000;
                    watchTimeStart = null;
                }
            }

            function setupPlayerEvents() {
                if (!muxPlayer) return;

                muxPlayer.addEventListener('play',    () => { startWatchTimer(); updateState('Playing'); });
                muxPlayer.addEventListener('pause',   () => { stopWatchTimer();  updateState('Paused'); });
                muxPlayer.addEventListener('waiting', () => { stopWatchTimer();  updateState('Buffering'); });
                muxPlayer.addEventListener('playing', () => { startWatchTimer(); updateState('Playing'); });
                muxPlayer.addEventListener('ended',   () => { stopWatchTimer();  updateState('Ended'); });
                muxPlayer.addEventListener('error',   (e) => { stopWatchTimer(); updateState('Error'); console.error('Player error:', e); });
                muxPlayer.addEventListener('seeking', () => { stopWatchTimer(); });
                muxPlayer.addEventListener('seeked',  () => { if (!muxPlayer.paused) startWatchTimer(); });
                muxPlayer.addEventListener('loadedmetadata', () => { updateInfo(); });
            }

            function startInfoUpdates() {
                updateInfo();
                infoInterval = setInterval(updateInfo, 500);
            }

            function updateInfo() {
                if (!muxPlayer) return;
                const duration = muxPlayer.duration;
                document.getElementById('info-duration').textContent = isFinite(duration) ? formatTime(duration) : 'â€”';

                const currentTime = muxPlayer.currentTime;
                document.getElementById('info-current-time').textContent = isFinite(currentTime) ? formatTime(currentTime) : 'â€”';

                const volume = muxPlayer.volume;
                const muted = muxPlayer.muted;
                document.getElementById('info-volume').textContent = muted ? 'Muted' : `${Math.round(volume * 100)}%`;

                const buffered = muxPlayer.buffered;
                if (buffered && buffered.length > 0) {
                    const bufferedEnd = buffered.end(buffered.length - 1);
                    const bufferedPercent = duration ? Math.round((bufferedEnd / duration) * 100) : 0;
                    document.getElementById('info-buffered').textContent = `${bufferedPercent}%`;
                } else {
                    document.getElementById('info-buffered').textContent = '0%';
                }
                document.getElementById('info-stream-type').textContent = 'on-demand';
            }

            function updateState(state) {
                document.getElementById('info-state').textContent = state;
            }

            function formatTime(seconds) {
                if (!isFinite(seconds)) return 'â€”';
                const h = Math.floor(seconds / 3600);
                const m = Math.floor((seconds % 3600) / 60);
                const s = Math.floor(seconds % 60);
                if (h > 0) return `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
                return `${m}:${s.toString().padStart(2, '0')}`;
            }

            function formatBytes(bytes) {
                if (bytes === 0) return '0 B';
                if (bytes < 1024) return bytes + ' B';
                if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
                if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
                return (bytes / (1024 * 1024 * 1024)).toFixed(2) + ' GB';
            }
        });
    </script>
</body>
</html>
